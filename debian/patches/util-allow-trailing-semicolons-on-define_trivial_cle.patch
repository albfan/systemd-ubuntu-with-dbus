From: Lennart Poettering <lennart@poettering.net>
Date: Mon, 14 Oct 2013 04:59:26 +0200
Subject: util: allow trailing semicolons on define_trivial_cleanup_func lines

Emacs C indenting really gets confused by these lines if they carry no
trailing semicolon, hence let's make this nicer for good old emacs. The
other macros which define functions already do this too, so let's copy
the scheme here.

Also, let's use an uppercase name for the macro. So far our rough rule
was that macros that are totally not function-like (like this ones,
which define a function) are uppercase. (Well, admittedly it is a rough
rule only, for example function and variable decorators are all
lower-case SINCE THE CONSTANT YELLING IN THE SOURCES WOULD SUCK, and
also they at least got underscore prefixes.) Also, the macros that
define functions that we already have are all uppercase, so let's do the
same here...

Conflicts:
	src/gpt-auto-generator/gpt-auto-generator.c
---
 src/gpt-auto-generator/gpt-auto-generator.c | 157 ++++++++++------------------
 src/journal/journal-internal.h              |   2 +-
 src/shared/fdset.h                          |   2 +-
 src/shared/set.h                            |   4 +-
 src/shared/strv.h                           |   2 +-
 src/shared/udev-util.h                      |  10 +-
 src/shared/util.h                           |  19 ++--
 src/tmpfiles/tmpfiles.c                     |   2 +-
 8 files changed, 78 insertions(+), 120 deletions(-)

diff --git a/src/gpt-auto-generator/gpt-auto-generator.c b/src/gpt-auto-generator/gpt-auto-generator.c
index d2b4213a..25440e77 100644
--- a/src/gpt-auto-generator/gpt-auto-generator.c
+++ b/src/gpt-auto-generator/gpt-auto-generator.c
@@ -36,6 +36,7 @@
 #include "missing.h"
 #include "sd-id128.h"
 #include "libudev.h"
+#include "udev-util.h"
 #include "special.h"
 #include "unit-name.h"
 #include "virt.h"
@@ -48,12 +49,12 @@
  *
  */
 
+#define GPT_SWAP SD_ID128_MAKE(06,57,fd,6d,a4,ab,43,c4,84,e5,09,33,c8,4b,4f,4f)
+#define GPT_HOME SD_ID128_MAKE(93,3a,c7,e1,2e,b4,4f,13,b8,44,0e,14,e2,ae,f9,15)
+
 static const char *arg_dest = "/tmp";
 
-static inline void blkid_free_probep(blkid_probe *b) {
-        if (*b)
-                blkid_free_probe(*b);
-}
+DEFINE_TRIVIAL_CLEANUP_FUNC(blkid_probe, blkid_free_probe);
 #define _cleanup_blkid_freep_probe_ _cleanup_(blkid_free_probep)
 
 static int verify_gpt_partition(const char *node, sd_id128_t *type, unsigned *nr, char **fstype) {
@@ -113,13 +114,13 @@ static int verify_gpt_partition(const char *node, sd_id128_t *type, unsigned *nr
 
 
         if (fstype) {
-                char *fst;
-
                 errno = 0;
                 r = blkid_probe_lookup_value(b, "TYPE", &v, NULL);
                 if (r != 0)
                         *fstype = NULL;
                 else {
+                        char *fst;
+
                         fst = strdup(v);
                         if (!fst)
                                 return -ENOMEM;
@@ -181,7 +182,7 @@ static int add_swap(const char *path, const char *fstype) {
 }
 
 static int add_home(const char *path, const char *fstype) {
-        _cleanup_free_ char *unit = NULL, *lnk = NULL;
+        _cleanup_free_ char *unit = NULL, *lnk = NULL, *fsck = NULL;
         _cleanup_fclose_ FILE *f = NULL;
 
         if (dir_is_empty("/home") <= 0)
@@ -199,19 +200,23 @@ static int add_home(const char *path, const char *fstype) {
                 return -errno;
         }
 
+        fsck = unit_name_from_path_instance("systemd-fsck", path, ".service");
+        if (!fsck)
+                return log_oom();
+
         fprintf(f,
                 "# Automatically generated by systemd-gpt-auto-generator\n\n"
                 "[Unit]\n"
                 "DefaultDependencies=no\n"
-                "After=" SPECIAL_LOCAL_FS_PRE_TARGET "\n"
+                "Requires=%s\n"
+                "After=" SPECIAL_LOCAL_FS_PRE_TARGET " %s\n"
                 "Conflicts=" SPECIAL_UMOUNT_TARGET "\n"
                 "Before=" SPECIAL_UMOUNT_TARGET " " SPECIAL_LOCAL_FS_TARGET "\n\n"
                 "[Mount]\n"
                 "What=%s\n"
                 "Where=/home\n"
-                "Type=%s\n"
-                "FsckPassNo=2\n",
-                path, fstype);
+                "Type=%s\n",
+                fsck, fsck, path, fstype);
 
         fflush(f);
         if (ferror(f)) {
@@ -234,97 +239,80 @@ static int add_home(const char *path, const char *fstype) {
 }
 
 static int enumerate_partitions(struct udev *udev, dev_t dev) {
-        struct udev_enumerate *e = NULL;
-        struct udev_device *parent = NULL, *d = NULL;
+        struct udev_device *parent = NULL;
+        _cleanup_udev_enumerate_unref_ struct udev_enumerate *e = NULL;
+        _cleanup_udev_device_unref_ struct udev_device *d = NULL;
         struct udev_list_entry *first, *item;
         unsigned home_nr = (unsigned) -1;
         _cleanup_free_ char *home = NULL, *home_fstype = NULL;
         int r;
 
         e = udev_enumerate_new(udev);
-        if (!e) {
-                r = log_oom();
-                goto finish;
-        }
+        if (!e)
+                return log_oom();
 
         d = udev_device_new_from_devnum(udev, 'b', dev);
-        if (!d) {
-                r = log_oom();
-                goto finish;
-        }
+        if (!d)
+                return log_oom();
 
         parent = udev_device_get_parent(d);
-        if (!parent) {
-                r = log_oom();
-                goto finish;
-        }
+        if (!parent)
+                return log_oom();
 
         r = udev_enumerate_add_match_parent(e, parent);
-        if (r < 0) {
-                r = log_oom();
-                goto finish;
-        }
+        if (r < 0)
+                return log_oom();
 
         r = udev_enumerate_add_match_subsystem(e, "block");
-        if (r < 0) {
-                r = log_oom();
-                goto finish;
-        }
+        if (r < 0)
+                return log_oom();
 
         r = udev_enumerate_scan_devices(e);
         if (r < 0) {
                 log_error("Failed to enumerate partitions on /dev/block/%u:%u: %s",
                           major(dev), minor(dev), strerror(-r));
-                goto finish;
+                return r;
         }
 
         first = udev_enumerate_get_list_entry(e);
         udev_list_entry_foreach(item, first) {
                 _cleanup_free_ char *fstype = NULL;
                 const char *node = NULL;
-                struct udev_device *q;
+                _cleanup_udev_device_unref_ struct udev_device *q;
                 sd_id128_t type_id;
                 unsigned nr;
 
                 q = udev_device_new_from_syspath(udev, udev_list_entry_get_name(item));
-                if (!q) {
-                        r = log_oom();
-                        goto finish;
-                }
+                if (!q)
+                        return log_oom();
 
                 if (udev_device_get_devnum(q) == udev_device_get_devnum(d))
-                        goto skip;
+                        continue;
 
                 if (udev_device_get_devnum(q) == udev_device_get_devnum(parent))
-                        goto skip;
+                        continue;
 
                 node = udev_device_get_devnode(q);
-                if (!node) {
-                        r = log_oom();
-                        goto finish;
-                }
+                if (!node)
+                        return log_oom();
 
                 r = verify_gpt_partition(node, &type_id, &nr, &fstype);
                 if (r < 0) {
                         log_error("Failed to verify GPT partition %s: %s",
                                   node, strerror(-r));
-                        udev_device_unref(q);
-                        goto finish;
+                        return r;
                 }
                 if (r == 0)
-                        goto skip;
+                        continue;
 
-                if (sd_id128_equal(type_id, SD_ID128_MAKE(06,57,fd,6d,a4,ab,43,c4,84,e5,09,33,c8,4b,4f,4f)))
+                if (sd_id128_equal(type_id, GPT_SWAP))
                         add_swap(node, fstype);
-                else if (sd_id128_equal(type_id, SD_ID128_MAKE(93,3a,c7,e1,2e,b4,4f,13,b8,44,0e,14,e2,ae,f9,15))) {
-
+                else if (sd_id128_equal(type_id, GPT_HOME)) {
                         if (!home || nr < home_nr) {
                                 free(home);
                                 home = strdup(node);
-                                if (!home) {
-                                        r = log_oom();
-                                        goto finish;
-                                }
+                                if (!home)
+                                        return log_oom();
 
                                 home_nr = nr;
 
@@ -333,27 +321,16 @@ static int enumerate_partitions(struct udev *udev, dev_t dev) {
                                 fstype = NULL;
                         }
                 }
-
-        skip:
-                udev_device_unref(q);
         }
 
         if (home && home_fstype)
                 add_home(home, home_fstype);
 
-finish:
-        if (d)
-                udev_device_unref(d);
-
-        if (e)
-                udev_enumerate_unref(e);
-
-
         return r;
 }
 
 static int get_btrfs_block_device(const char *path, dev_t *dev) {
-        struct btrfs_ioctl_fs_info_args fsi;
+        struct btrfs_ioctl_fs_info_args fsi = {};
         _cleanup_close_ int fd = -1;
         uint64_t id;
 
@@ -364,7 +341,6 @@ static int get_btrfs_block_device(const char *path, dev_t *dev) {
         if (fd < 0)
                 return -errno;
 
-        zero(fsi);
         if (ioctl(fd, BTRFS_IOC_FS_INFO, &fsi) < 0)
                 return -errno;
 
@@ -373,12 +349,11 @@ static int get_btrfs_block_device(const char *path, dev_t *dev) {
                 return 0;
 
         for (id = 1; id <= fsi.max_id; id++) {
-                struct btrfs_ioctl_dev_info_args di;
+                struct btrfs_ioctl_dev_info_args di = {
+                        .devid = id,
+                };
                 struct stat st;
 
-                zero(di);
-                di.devid = id;
-
                 if (ioctl(fd, BTRFS_IOC_DEV_INFO, &di) < 0) {
                         if (errno == ENODEV)
                                 continue;
@@ -427,44 +402,31 @@ static int get_block_device(const char *path, dev_t *dev) {
 }
 
 static int devno_to_devnode(struct udev *udev, dev_t devno, char **ret) {
-        struct udev_device *d = NULL;
+        _cleanup_udev_device_unref_ struct udev_device *d;
         const char *t;
         char *n;
-        int r;
 
         d = udev_device_new_from_devnum(udev, 'b', devno);
-        if (!d) {
-                r = log_oom();
-                goto finish;
-        }
+        if (!d)
+                return log_oom();
 
         t = udev_device_get_devnode(d);
-        if (!t) {
-                r = -ENODEV;
-                goto finish;
-        }
+        if (!t)
+                return -ENODEV;
 
         n = strdup(t);
-        if (!n) {
-                r = -ENOMEM;
-                goto finish;
-        }
+        if (!n)
+                return -ENOMEM;
 
         *ret = n;
-        r = 0;
-
-finish:
-        if (d)
-                udev_device_unref(d);
-
-        return r;
+        return 0;
 }
 
 int main(int argc, char *argv[]) {
         _cleanup_free_ char *node = NULL;
-        struct udev *udev = NULL;
+        _cleanup_udev_unref_ struct udev *udev = NULL;
         dev_t devno;
-        int r;
+        int r = 0;
 
         if (argc > 1 && argc != 4) {
                 log_error("This program takes three or no arguments.");
@@ -483,13 +445,11 @@ int main(int argc, char *argv[]) {
 
         if (in_initrd()) {
                 log_debug("In initrd, exiting.");
-                r = 0;
                 goto finish;
         }
 
         if (detect_container(NULL) > 0) {
                 log_debug("In a container, exiting.");
-                r = 0;
                 goto finish;
         }
 
@@ -528,8 +488,5 @@ int main(int argc, char *argv[]) {
         r = enumerate_partitions(udev, devno);
 
 finish:
-        if (udev)
-                udev_unref(udev);
-
         return r < 0 ? EXIT_FAILURE : EXIT_SUCCESS;
 }
diff --git a/src/journal/journal-internal.h b/src/journal/journal-internal.h
index 1bc912c9..3355fca6 100644
--- a/src/journal/journal-internal.h
+++ b/src/journal/journal-internal.h
@@ -135,7 +135,7 @@ struct sd_journal {
 char *journal_make_match_string(sd_journal *j);
 void journal_print_header(sd_journal *j);
 
-define_trivial_cleanup_func(sd_journal*, sd_journal_close)
+DEFINE_TRIVIAL_CLEANUP_FUNC(sd_journal*, sd_journal_close);
 #define _cleanup_journal_close_ _cleanup_(sd_journal_closep)
 
 #define JOURNAL_FOREACH_DATA_RETVAL(j, data, l, retval)                     \
diff --git a/src/shared/fdset.h b/src/shared/fdset.h
index d0dc875a..b91b4309 100644
--- a/src/shared/fdset.h
+++ b/src/shared/fdset.h
@@ -48,5 +48,5 @@ int fdset_iterate(FDSet *s, Iterator *i);
 #define FDSET_FOREACH(fd, fds, i) \
         for ((i) = ITERATOR_FIRST, (fd) = fdset_iterate((fds), &(i)); (fd) >= 0; (fd) = fdset_iterate((fds), &(i)))
 
-define_trivial_cleanup_func(FDSet*, fdset_free)
+DEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);
 #define _cleanup_fdset_free_ _cleanup_(fdset_freep)
diff --git a/src/shared/set.h b/src/shared/set.h
index a291470c..5612478d 100644
--- a/src/shared/set.h
+++ b/src/shared/set.h
@@ -73,7 +73,7 @@ char **set_get_strv(Set *s);
 #define SET_FOREACH_BACKWARDS(e, s, i) \
         for ((i) = ITERATOR_LAST, (e) = set_iterate_backwards((s), &(i)); (e); (e) = set_iterate_backwards((s), &(i)))
 
-define_trivial_cleanup_func(Set*, set_free)
-define_trivial_cleanup_func(Set*, set_free_free)
+DEFINE_TRIVIAL_CLEANUP_FUNC(Set*, set_free);
+DEFINE_TRIVIAL_CLEANUP_FUNC(Set*, set_free_free);
 #define _cleanup_set_free_ _cleanup_(set_freep)
 #define _cleanup_set_free_free_ _cleanup_(set_free_freep)
diff --git a/src/shared/strv.h b/src/shared/strv.h
index 4d117f82..f6fb033a 100644
--- a/src/shared/strv.h
+++ b/src/shared/strv.h
@@ -30,7 +30,7 @@ char *strv_find(char **l, const char *name) _pure_;
 char *strv_find_prefix(char **l, const char *name) _pure_;
 
 void strv_free(char **l);
-define_trivial_cleanup_func(char**, strv_free)
+DEFINE_TRIVIAL_CLEANUP_FUNC(char**, strv_free);
 #define _cleanup_strv_free_ _cleanup_(strv_freep)
 
 char **strv_copy(char * const *l);
diff --git a/src/shared/udev-util.h b/src/shared/udev-util.h
index bff8f5fb..27677af8 100644
--- a/src/shared/udev-util.h
+++ b/src/shared/udev-util.h
@@ -24,11 +24,11 @@
 #include "udev.h"
 #include "util.h"
 
-define_trivial_cleanup_func(struct udev*, udev_unref)
-define_trivial_cleanup_func(struct udev_device*, udev_device_unref)
-define_trivial_cleanup_func(struct udev_enumerate*, udev_enumerate_unref)
-define_trivial_cleanup_func(struct udev_event*, udev_event_unref)
-define_trivial_cleanup_func(struct udev_rules*, udev_rules_unref)
+DEFINE_TRIVIAL_CLEANUP_FUNC(struct udev*, udev_unref);
+DEFINE_TRIVIAL_CLEANUP_FUNC(struct udev_device*, udev_device_unref);
+DEFINE_TRIVIAL_CLEANUP_FUNC(struct udev_enumerate*, udev_enumerate_unref);
+DEFINE_TRIVIAL_CLEANUP_FUNC(struct udev_event*, udev_event_unref);
+DEFINE_TRIVIAL_CLEANUP_FUNC(struct udev_rules*, udev_rules_unref);
 
 #define _cleanup_udev_unref_ _cleanup_(udev_unrefp)
 #define _cleanup_udev_device_unref_ _cleanup_(udev_device_unrefp)
diff --git a/src/shared/util.h b/src/shared/util.h
index 2c41765f..bdbdca3b 100644
--- a/src/shared/util.h
+++ b/src/shared/util.h
@@ -555,11 +555,12 @@ static inline void freep(void *p) {
         free(*(void**) p);
 }
 
-#define define_trivial_cleanup_func(type, func) \
-        static inline void func##p(type *p) {   \
-        if (*p)                                 \
-                func(*p);                       \
-        }                                       \
+#define DEFINE_TRIVIAL_CLEANUP_FUNC(type, func)                 \
+        static inline void func##p(type *p) {                   \
+                if (*p)                                         \
+                        func(*p);                               \
+        }                                                       \
+        struct __useless_struct_to_allow_trailing_semicolon__
 
 static inline void closep(int *fd) {
         if (*fd >= 0)
@@ -570,10 +571,10 @@ static inline void umaskp(mode_t *u) {
         umask(*u);
 }
 
-define_trivial_cleanup_func(FILE*, fclose)
-define_trivial_cleanup_func(FILE*, pclose)
-define_trivial_cleanup_func(DIR*, closedir)
-define_trivial_cleanup_func(FILE*, endmntent)
+DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, fclose);
+DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, pclose);
+DEFINE_TRIVIAL_CLEANUP_FUNC(DIR*, closedir);
+DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, endmntent);
 
 #define _cleanup_free_ _cleanup_(freep)
 #define _cleanup_close_ _cleanup_(closep)
diff --git a/src/tmpfiles/tmpfiles.c b/src/tmpfiles/tmpfiles.c
index 7e873af8..e23847bb 100644
--- a/src/tmpfiles/tmpfiles.c
+++ b/src/tmpfiles/tmpfiles.c
@@ -998,7 +998,7 @@ static void item_free(Item *i) {
         free(i);
 }
 
-define_trivial_cleanup_func(Item*, item_free)
+DEFINE_TRIVIAL_CLEANUP_FUNC(Item*, item_free);
 #define _cleanup_item_free_ _cleanup_(item_freep)
 
 static bool item_equal(Item *a, Item *b) {
